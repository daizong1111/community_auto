"""
此模块使用 Playwright 框架实现会议室管理模块的 UI 自动化测试，
包含增、删、改、查功能的测试用例。
"""
import random
import time

import allure

# 生成随机身份证号码和手机号码，防止数据重复
from faker import Faker

fake = Faker('zh_CN')

from base_case import BaseCase

from playwright.sync_api import expect, sync_playwright
import pytest
import logging

from pages.基础信息.实有房屋.一房一档 import PageHouseArchive

# 配置日志记录器
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')





@pytest.fixture(scope="module")
def 一房一档页面(浏览器已打开的页面):
    # 将页面封装为一房一档页面
    page = PageHouseArchive(浏览器已打开的页面)
    yield page

@pytest.fixture(scope="class")
def 前置操作_获取房屋编码(一房一档页面):
    payload = 一房一档页面.获取请求的payload数据("刷新", "ybdsPerson/getHousePersonMessage")
    return payload["fwbm"]

@pytest.fixture(scope="class")
def 新增数据_批量删除前(一房一档页面, db_connection, 随机门牌号, 新增的数据量):
    test_add = TestAdd()
    test_add.test_add_success(一房一档页面, db_connection, 随机门牌号, "天王巷小区", "官塘新村", "1单元", "102", "自住",
                              "1层", "住宅", "国有房产", "100",
                              "小区环境宜人，绿化覆盖率高，四季皆有景。内部设有儿童游乐区、健身角，方便居民休闲活动。物业服务响应及时，保洁到位，安保巡逻频繁，让人住得安心。邻里关系和谐，常有社区活动增进感情。停车管理有序，虽有高峰时段紧张，但总体尚可。周边配套齐全，超市、餐厅、学校、医院均在步行范围内。交通便捷，多条公交线路经过，离地铁站也不远。房屋多为中高层，采光良好。唯一不足是部分楼栋间存在视野遮挡。总体而言，是一个适宜居住、生活便利的成熟社区。",
                              r"C:\Users\Administrator\Pictures\111.png")


@pytest.mark.usefixtures("一房一档页面")  # 显式声明夹具
class TestAdd(BaseCase):

    @pytest.mark.parametrize(
        "姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片, 与房主关系, 人口标签, 国籍, 文化程度, 备注",

        [
            ("新增-成功", "男", "常住人口", "群众", "340421199711170022",
             "汉族", "北京市/市辖区/东城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "租客", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            ("新增-成功-备注200字", "男", "常住人口", "群众", "340421199711170022",
             "汉族", "北京市/市辖区/东城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "租客", "现役军人", "中国", "大学本科",
             "小区环境宜人，绿化覆盖率高，四季皆有景。内部设有儿童游乐区、健身角，方便居民休闲活动。物业服务响应及时，保洁到位，安保巡逻频繁，让人住得安心。邻里关系和谐，常有社区活动增进感情。停车管理有序，虽有高峰时段紧张，但总体尚可。周边配套齐全，超市、餐厅、学校、医院均在步行范围内。交通便捷，多条公交线路经过，离地铁站也不远。房屋多为中高层，采光良好。唯一不足是部分楼栋间存在视野遮挡。总体而言，是一个适宜居住、生活便利的成熟社区。"
             )
            # 添加更多测试数据集
        ],
        # ids=["新增-成功"
        #
        #      ]
    )
    @allure.step("测试新增人员-成功")
    def test_add_success(self, 一房一档页面,
                         db_connection, 姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片,
                         与房主关系, 人口标签, 国籍, 文化程度, 备注
                         ):
        # 生成随机的身份证号和手机号
        身份证号码 = fake.ssn()
        手机号码 = fake.phone_number()
        # 统计数据库中的数据条数
        数据量_新增前 = 一房一档页面.统计数据库表中的记录数(db_connection)
        # 点击新增按钮
        一房一档页面.click_button("新增")
        self.log_step("点击新增按钮")
        # 填写表单信息
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(
            表单最上层定位=一房一档页面.定位器_新增表单(), 姓名=姓名, 性别=性别, 人口类型=人口类型, 政治面貌=政治面貌,
            身份证号码=身份证号码, 民族=民族, 籍贯=籍贯, 手机号码=手机号码, 人脸照片=人脸照片, 与房主关系=与房主关系,
            人口标签=人口标签, 国籍=国籍, 文化程度=文化程度, 备注=备注)
        self.log_step("填写表单信息")
        # 点击提交按钮
        一房一档页面.click_button("确定")
        self.log_step("点击提交按钮")
        # 断言操作成功字样在页面出现
        expect(一房一档页面.page.get_by_text("保存成功")).to_be_visible(timeout=5000)
        self.log_step("验证新增成功-页面提示信息")
        # 等待1秒
        一房一档页面.page.wait_for_timeout(1000)
        # 重新连接数据库，并提交事务
        db_connection.ping(reconnect=True)
        db_connection.commit()  # 提交事务确保可见，必须加上这段代码，否则读取到的数据数仍然是新增之前的
        # 统计数据库中的数据条数
        数据量_新增后 = 一房一档页面.统计数据库表中的记录数(db_connection)
        # 断言新增后数据库表中数据量增加了1
        assert 数据量_新增后 == 数据量_新增前 + 1, f"新增失败，数据库中数据量没有增加，新增前的数据量为{数据量_新增前}，新增后的数据量为{数据量_新增后}"
        self.log_step("验证新增成功-数据库校验")

    @pytest.mark.parametrize(
        "姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片, 与房主关系, 人口标签, 国籍, 文化程度, 备注",

        [
            ("", "男", "常住人口", "群众", "340421199711170022",
             "汉族", "北京市/市辖区/东城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "租客", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            ("新增-成功", "", "常住人口", "群众", "340421199711170022",
             "汉族", "北京市/市辖区/东城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "租客", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            ("新增-成功", "男", "", "群众", "340421199711170022",
             "汉族", "北京市/市辖区/东城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "租客", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            ("新增-成功", "男", "常住人口", "群众", "",
             "汉族", "北京市/市辖区/东城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "租客", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            ("新增-成功", "男", "常住人口", "群众", "340421199711170022",
             "汉族", "北京市/市辖区/东城区", "", r"C:\Users\Administrator\Pictures\111.png",
             "租客", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            ("新增-成功", "男", "常住人口", "群众", "340421199711170022",
             "汉族", "北京市/市辖区/东城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            # 添加更多测试数据集
        ],
        # ids=[
        #      "新增-失败-必填项为空-会议室名称",
        #      "新增-失败-必填项为空-容纳人数",
        #      "新增-失败-必填项为空-会议室位置",
        #      "新增-失败-必填项为空-会议室状态",
        #      '新增-失败-必填项为空-会议室设备',
        #      '新增-失败-必填项为空-管理部门',
        #      '新增-失败-必填项为空-管理人',
        #      '新增-失败-必填项为空-审批人',
        #      '新增-失败-必填项为空-可预约的时间范围',
        #      '新增-失败-必填项为空-单次可预约最长时间',
        #      ]
    )
    @pytest.mark.usefixtures("后置操作_刷新页面")
    @allure.step("测试新增人员-失败-必填项缺失")
    def test_add__miss_data(self, 一房一档页面,
                            db_connection,
                            姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片, 与房主关系,
                            人口标签, 国籍, 文化程度, 备注
                            ):
        # 统计数据库中的数据条数
        数据量_新增前 = 一房一档页面.统计数据库表中的记录数(db_connection)
        # 点击新增按钮
        一房一档页面.click_button("新增")
        self.log_step("点击新增按钮")
        # 填写表单信息
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(
            表单最上层定位=一房一档页面.定位器_新增表单(), 姓名=姓名, 性别=性别, 人口类型=人口类型, 政治面貌=政治面貌,
            身份证号码=身份证号码, 民族=民族, 籍贯=籍贯, 手机号码=手机号码, 人脸照片=人脸照片, 与房主关系=与房主关系,
            人口标签=人口标签, 国籍=国籍, 文化程度=文化程度, 备注=备注)
        # 小区信息页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(备注=备注)
        self.log_step("填写表单信息")
        # 点击提交按钮
        一房一档页面.click_button("确定")
        self.log_step("点击提交按钮")
        # 断言操作成功字样未在页面出现
        expect(一房一档页面.page.get_by_text("保存成功")).not_to_be_visible(timeout=5000)
        # 验证页面出现了错误提示，不校验具体内容
        一房一档页面.验证表单项中出现错误提示()
        # assert 一房一档页面.page.get_by_text("不能为空").count() > 0
        self.log_step("验证新增失败-必填项缺失-页面提示信息")
        # 等待1秒
        一房一档页面.page.wait_for_timeout(1000)
        # 重新连接数据库，并提交事务
        db_connection.ping(reconnect=True)
        db_connection.commit()  # 提交事务确保可见，必须加上这段代码，否则读取到的数据数仍然是新增之前的
        # 统计数据库中的数据条数
        数据量_新增后 = 一房一档页面.统计数据库表中的记录数(db_connection)
        assert 数据量_新增后 == 数据量_新增前, f"数据库校验失败，数据库中数据量发生变化，新增前的数据量为{数据量_新增前}，新增后的数据量为{数据量_新增后}"
        self.log_step("验证新增失败-必填项缺失-数据库校验")

    @pytest.mark.usefixtures("后置操作_刷新页面")
    @pytest.mark.parametrize(
        "姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片, 与房主关系, 人口标签, 国籍, 文化程度, 备注",

        [
            ("新增-成功", "男", "常住人口", "群众", "340421199711170020",
             "汉族", "北京市/市辖区/东城区", "", r"C:\Users\Administrator\Pictures\111.png",
             "租客", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            ("新增-成功", "男", "常住人口", "群众", "",
             "汉族", "北京市/市辖区/东城区", "15655426822", r"C:\Users\Administrator\Pictures\111.png",
             "租客", "现役军人", "中国", "大学本科", "本人为高级军官"
             )
            # 添加更多测试数据集
        ],
    )
    @allure.step("测试新增人员-失败-去重校验：身份证号和手机号不能重复")
    def test_add_repeat_validation(self, 一房一档页面,
                                   db_connection,
                                   姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片,
                                   与房主关系, 人口标签, 国籍, 文化程度, 备注
                                   ):
        # 保证手机号码和身份证号码中只有一个是重复的
        if 身份证号码 == "":
            身份证号码 = fake.ssn()
        if 手机号码 == "":
            手机号码 = fake.phone_number()
        # 统计数据库中的数据条数
        数据量_新增前 = 一房一档页面.统计数据库表中的记录数(db_connection)
        # 点击新增按钮
        一房一档页面.click_button("新增")
        self.log_step("点击新增按钮")
        # 填写表单信息
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(
            表单最上层定位=一房一档页面.定位器_新增表单(), 姓名=姓名, 性别=性别, 人口类型=人口类型, 政治面貌=政治面貌,
            身份证号码=身份证号码, 民族=民族, 籍贯=籍贯, 手机号码=手机号码, 人脸照片=人脸照片, 与房主关系=与房主关系,
            人口标签=人口标签, 国籍=国籍, 文化程度=文化程度, 备注=备注)
        # 小区信息页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(备注=备注)
        self.log_step("填写表单信息")
        # 点击提交按钮
        一房一档页面.click_button("确定")
        self.log_step("点击提交按钮")
        # 断言该人员已存在字样在页面出现
        一房一档页面.验证页面顶部出现全局提示("该人员已经存在")
        self.log_step("验证新增失败-去重校验-页面提示信息")
        # 等待1秒
        一房一档页面.page.wait_for_timeout(1000)
        # 重新连接数据库，并提交事务
        db_connection.ping(reconnect=True)
        db_connection.commit()  # 提交事务确保可见，必须加上这段代码，否则读取到的数据数仍然是新增之前的
        # 统计数据库中的数据条数
        数据量_新增后 = 一房一档页面.统计数据库表中的记录数(db_connection)

        assert 数据量_新增后 == 数据量_新增前, f"数据库校验失败，数据库中数据量发生变化，新增前的数据量为{数据量_新增前}，新增后的数据量为{数据量_新增后}"
        self.log_step("验证新增失败-去重校验-数据库校验")

    @pytest.mark.usefixtures("后置操作_刷新页面")
    @pytest.mark.parametrize(
        "姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片, 与房主关系, 人口标签, 国籍, 文化程度, 备注",

        [
            ("新增-失败-房主唯一性校验", "男", "常住人口", "群众", "340421199711170020",
             "汉族", "北京市/市辖区/东城区", "", r"C:\Users\Administrator\Pictures\111.png",
             "房主", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            # 添加更多测试数据集
        ],
    )
    @allure.step("测试新增人员-房主唯一性校验")
    def test_add_owner_validation(self, 一房一档页面,
                                  db_connection,
                                  姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片,
                                  与房主关系, 人口标签, 国籍, 文化程度, 备注
                                  ):
        # 保证手机号码和身份证号码不重复
        身份证号码 = fake.ssn()
        手机号码 = fake.phone_number()
        # 统计数据库中的数据条数
        数据量_新增前 = 一房一档页面.统计数据库表中的记录数(db_connection)
        # 点击新增按钮
        一房一档页面.click_button("新增")
        self.log_step("点击新增按钮")
        # 填写表单信息
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(
            表单最上层定位=一房一档页面.定位器_新增表单(), 姓名=姓名, 性别=性别, 人口类型=人口类型, 政治面貌=政治面貌,
            身份证号码=身份证号码, 民族=民族, 籍贯=籍贯, 手机号码=手机号码, 人脸照片=人脸照片, 与房主关系=与房主关系,
            人口标签=人口标签, 国籍=国籍, 文化程度=文化程度, 备注=备注)
        # 小区信息页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(备注=备注)
        self.log_step("填写表单信息")
        # 点击提交按钮
        一房一档页面.click_button("确定")
        self.log_step("点击提交按钮")
        # 断言该人员已存在字样在页面出现
        一房一档页面.验证页面顶部出现全局提示("一房只允许存在一个房主")
        self.log_step("验证新增失败-房主唯一性校验-页面提示信息")
        # 等待1秒
        一房一档页面.page.wait_for_timeout(1000)
        # 重新连接数据库，并提交事务
        db_connection.ping(reconnect=True)
        db_connection.commit()  # 提交事务确保可见，必须加上这段代码，否则读取到的数据数仍然是新增之前的
        # 统计数据库中的数据条数
        数据量_新增后 = 一房一档页面.统计数据库表中的记录数(db_connection)

        assert 数据量_新增后 == 数据量_新增前, f"数据库校验失败，数据库中数据量发生变化，新增前的数据量为{数据量_新增前}，新增后的数据量为{数据量_新增后}"
        self.log_step("验证新增失败-房主唯一性校验-数据库校验")

    @pytest.mark.usefixtures("后置操作_刷新页面")
    @allure.step("测试新增人员-前端格式校验与数据合法性")
    def test_add_frontend_validation(
            self, 一房一档页面, db_connection,
    ):
        一房一档页面.click_button("新增")
        self.log_step("点击新增按钮")

        # 输入手机号码
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    手机号码="13812345")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    手机号码="138123456789")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    手机号码="2381234567")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    手机号码="12812345678")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    手机号码="138-1234-567")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    手机号码="138 1234 567")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    手机号码="#381234567")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        # 输入身份证号
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    身份证号码="1101056903123")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    身份证号码="1101056903123456")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    身份证号码="1101051992A03123456")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    身份证号码="11010519920312345Y")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_新增表单(),
                                                                    身份证号码="110105-19920312-3456")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")


@pytest.mark.usefixtures("一房一档页面")  # 显式声明夹具
class TestEdit(BaseCase):
    @pytest.mark.parametrize(
        "待修改的姓名, 姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片,与房主关系, 人口标签, 国籍, 文化程度, 备注",

        [
            ("石岱宗", "修改-成功", "女", "流动人口", "中国民主同盟盟员", "340421199711170022",
             "蒙古族", "北京市/市辖区/西城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "配偶", "", "南苏丹", "研究生教育", "本人为低等军官"
             ),
            # 添加更多测试数据集
        ],
        # ids=["修改-成功"]
    )
    @allure.step("测试修改小区")
    def test_edit_success(self, 一房一档页面,
                          db_connection, 待修改的姓名, 姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码,
                          人脸照片,
                          与房主关系, 人口标签, 国籍, 文化程度, 备注):
        # 保证手机号码和身份证号码不重复
        # 身份证号码 = fake.ssn()
        # 手机号码 = fake.phone_number()
        # 输入查询条件
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=待修改的姓名)
        self.log_step("输入查询条件")
        # 点击查询按钮
        一房一档页面.click_button("搜索")
        # 点击编辑按钮
        一房一档页面.点击编辑按钮(None)
        self.log_step("点击编辑按钮")
        # 填写表单信息
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(
            表单最上层定位=一房一档页面.定位器_编辑表单(), 姓名=姓名, 性别=性别, 人口类型=人口类型, 政治面貌=政治面貌,
            民族=民族, 籍贯=籍贯, 人脸照片=人脸照片, 与房主关系=与房主关系,
            人口标签=人口标签, 国籍=国籍, 文化程度=文化程度, 备注=备注)
        # 小区信息页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(备注=备注)
        self.log_step("填写表单信息")
        # 点击提交按钮
        一房一档页面.click_button("确定")
        self.log_step("点击提交按钮")
        # 点击提示弹窗中的确定按钮
        一房一档页面.点击提示弹窗中的确定按钮()
        # 断言操作成功字样在页面出现
        expect(一房一档页面.page.get_by_text("保存成功!")).to_be_visible(timeout=5000)
        self.log_step("验证修改成功-页面提示信息")
        # 等待1秒
        一房一档页面.page.wait_for_timeout(1000)
        # 重新连接数据库，并提交事务
        db_connection.ping(reconnect=True)
        db_connection.commit()  # 提交事务确保可见，必须加上这段代码，否则读取到的数据数仍然是新增之前的
        # 执行sql查询，断言一定能查到修改后的数据
        count = 一房一档页面.统计数据库表中的记录数_修改后(db_connection, 姓名)
        assert count > 0
        self.log_step("验证修改成功-数据库")
        # 输入查询条件
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=姓名)
        self.log_step("输入查询条件")
        # 点击查询按钮
        一房一档页面.click_button("搜索")
        一房一档页面.点击编辑按钮(None)
        一房一档页面.校验表单中数据成功修改(一房一档页面.定位器_编辑表单(), 性别=性别, 人口类型=人口类型,
                                            政治面貌=政治面貌,
                                            民族=民族, 籍贯=籍贯, 与房主关系=与房主关系,
                                            国籍=国籍, 文化程度=文化程度, 备注=备注)

    @pytest.mark.parametrize(
        "待修改的姓名, 姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片,与房主关系, 人口标签, 国籍, 文化程度, 备注",

        [
            ("修改-成功", "", "女", "流动人口", "中国民主同盟盟员", "340421199711170022",
             "蒙古族", "北京市/市辖区/西城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "配偶", "", "南苏丹", "研究生教育", "本人为低等军官"
             ),
            ("修改-成功", "修改-失败", "女", "流动人口", "中国民主同盟盟员", "",
             "蒙古族", "北京市/市辖区/西城区", "15655426823", r"C:\Users\Administrator\Pictures\111.png",
             "配偶", "", "南苏丹", "研究生教育", "本人为低等军官"
             ),
            ("修改-成功", "修改-失败", "女", "流动人口", "中国民主同盟盟员", "340421199711170022",
             "蒙古族", "北京市/市辖区/西城区", "", r"C:\Users\Administrator\Pictures\111.png",
             "配偶", "", "南苏丹", "研究生教育", "本人为低等军官"
             ),
            # 添加更多测试数据集
        ],

        # ids=[
        #      "新增-失败-必填项为空-会议室名称",
        #      "新增-失败-必填项为空-容纳人数",
        #      "新增-失败-必填项为空-会议室位置",
        #      ]
    )
    @pytest.mark.usefixtures("后置操作_刷新页面")
    @allure.step("测试编辑房屋-失败-必填项缺失")
    def test_edit__miss_data(self, 一房一档页面,
                             db_connection, 待修改的姓名, 姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯,
                             手机号码, 人脸照片,
                             与房主关系, 人口标签, 国籍, 文化程度, 备注
                             ):
        # 获取当前时间戳
        timestamp = int(time.time())
        if 姓名 != "":
            姓名 += f"_{timestamp}"
        # 输入查询条件
        # 修改后的门牌号 = "103"
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=待修改的姓名)
        self.log_step("输入查询条件")
        # 点击查询按钮
        一房一档页面.click_button("搜索")
        # 点击编辑按钮
        一房一档页面.点击编辑按钮(None)
        self.log_step("点击编辑按钮")
        # 填写表单信息
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(
            表单最上层定位=一房一档页面.定位器_编辑表单(), 姓名=姓名, 性别=性别, 人口类型=人口类型, 政治面貌=政治面貌,
            身份证号码=身份证号码,
            民族=民族, 籍贯=籍贯, 手机号码=手机号码, 人脸照片=人脸照片, 与房主关系=与房主关系,
            人口标签=人口标签, 国籍=国籍, 文化程度=文化程度, 备注=备注)
        # 小区信息页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(备注=备注)
        self.log_step("填写表单信息")
        # 点击提交按钮
        一房一档页面.click_button("确定")
        self.log_step("点击提交按钮")
        # 断言操作成功字样在页面出现
        expect(一房一档页面.page.get_by_text("保存成功!")).not_to_be_visible(timeout=5000)
        一房一档页面.验证表单项中出现错误提示()
        self.log_step("验证修改失败-页面提示信息")
        # 等待1秒
        一房一档页面.page.wait_for_timeout(1000)
        # 重新连接数据库，并提交事务
        db_connection.ping(reconnect=True)
        db_connection.commit()  # 提交事务确保可见，必须加上这段代码，否则读取到的数据数仍然是新增之前的
        # 执行sql查询，断言一定能查到修改后的数据
        count = 一房一档页面.统计数据库表中的记录数_修改后(db_connection, 姓名)
        assert count == 0
        self.log_step("验证修改失败-数据库")

    @pytest.mark.usefixtures("后置操作_刷新页面")
    @pytest.mark.parametrize(
        "待修改的姓名, 姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯, 手机号码, 人脸照片,与房主关系, 人口标签, 国籍, 文化程度, 备注",

        [
            ("修改-成功", "修改-失败", "男", "常住人口", "群众", None,
             "汉族", "北京市/市辖区/东城区", None, r"C:\Users\Administrator\Pictures\111.png",
             "房主", "现役军人", "中国", "大学本科", "本人为高级军官"
             ),
            # 添加更多测试数据集
        ],
    )
    @allure.step("测试编辑人员-失败-房主唯一性校验")
    def test_edit_repeat_validation(self, 一房一档页面,
                                    db_connection, 待修改的姓名, 姓名, 性别, 人口类型, 政治面貌, 身份证号码, 民族, 籍贯,
                                    手机号码, 人脸照片, 与房主关系, 人口标签, 国籍, 文化程度, 备注
                                    ):
        # 获取当前时间戳
        timestamp = int(time.time())
        if 姓名 != "":
            姓名 += f"_{timestamp}"
        # 输入查询条件
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=待修改的姓名)
        self.log_step("输入查询条件")
        # 点击查询按钮
        一房一档页面.click_button("搜索")
        # 点击编辑按钮
        一房一档页面.点击编辑按钮(None)
        self.log_step("点击编辑按钮")
        # 填写表单信息
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(
            表单最上层定位=一房一档页面.定位器_编辑表单(), 姓名=姓名, 性别=性别, 人口类型=人口类型, 政治面貌=政治面貌,
            身份证号码=身份证号码,
            民族=民族, 籍贯=籍贯, 手机号码=手机号码, 人脸照片=人脸照片, 与房主关系=与房主关系,
            人口标签=人口标签, 国籍=国籍, 文化程度=文化程度, 备注=备注)
        # 小区信息页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(备注=备注)
        self.log_step("填写表单信息")
        # 点击提交按钮
        一房一档页面.click_button("确定")
        self.log_step("点击提交按钮")
        # 断言操作失败字样在页面出现
        expect(一房一档页面.page.get_by_text("一房只允许存在一个房主")).to_be_visible(timeout=5000)
        self.log_step("验证修改失败-页面提示信息")
        # 等待1秒
        一房一档页面.page.wait_for_timeout(1000)
        # 重新连接数据库，并提交事务
        db_connection.ping(reconnect=True)
        db_connection.commit()  # 提交事务确保可见，必须加上这段代码，否则读取到的数据数仍然是新增之前的
        # 执行sql查询，断言一定能查到修改后的数据
        count = 一房一档页面.统计数据库表中的记录数_修改后(db_connection, 姓名)
        assert count == 0
        self.log_step("验证修改失败-数据库")

    @pytest.mark.usefixtures("后置操作_刷新页面")
    @allure.step("测试编辑人员-前端格式校验与数据合法性")
    def test_edit_frontend_validation(
            self, 一房一档页面, db_connection, 待修改的姓名="修改-成功"
    ):
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=待修改的姓名)
        self.log_step("输入查询条件")
        # 点击查询按钮
        一房一档页面.click_button("搜索")
        # 点击编辑按钮
        一房一档页面.点击编辑按钮(None)
        self.log_step("点击编辑按钮")

        # 输入手机号码
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    手机号码="13812345")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    手机号码="138123456789")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    手机号码="2381234567")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    手机号码="12812345678")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    手机号码="138-1234-567")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    手机号码="138 1234 567")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    手机号码="#381234567")
        self.log_step("填写手机号码")
        expect(一房一档页面.page.get_by_text("请填写正确的手机号码")).to_have_count(1)
        self.log_step("断言页面提示信息-手机号码")

        # 输入身份证号
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    身份证号码="1101056903123")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    身份证号码="1101056903123456")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    身份证号码="1101051992A03123456")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    身份证号码="11010519920312345Y")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")

        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(表单最上层定位=一房一档页面.定位器_编辑表单(),
                                                                    身份证号码="110105-19920312-3456")
        self.log_step("填写身份证号")
        expect(一房一档页面.page.get_by_text("请填写正确的身份证号")).to_have_count(1)
        self.log_step("断言页面提示信息-身份证号")


字典_人口类型代码 = {"常住人口": "1", "流动人口": "2", "境外人员": "4"}


def build_query_sql(姓名=None, 联系电话=None, 人口类型=None, 房屋编码=None):
    """
    根据给定参数动态生成小区查询 SQL。
    """
    sql = """select yp.*, b.xqmc, yph.yhzgxdm from ybds_house as yh left join ybds_person_house as yph on yh.fwbm = yph.fwbm left join ybds_person as yp on yph.person_id = yp.id left join base_village as b on yh.xqbm = b.xqbm where b.xqbm IN ( '340103225001001' , '340103225001002' , '340103225001111' , '340103225001223' , '2010005425' , '340103225002002' , '340103225003001' , '340103225001012' , '340103225002213' , '340103225003198' , '340103225003188' )"""

    # 存放动态条件列表和参数字典
    conditions = []
    params = {}

    if 姓名 is not None:
        # 添加选择小区条件
        conditions.append(f"and BINARY yp.xm = %(姓名)s")
        # 添加参数
        params["姓名"] = f"{姓名}"

    if 联系电话 is not None:
        conditions.append("and yp.sjhm = %(联系电话)s")
        params["联系电话"] = f"{联系电话}"

    if 人口类型 is not None:
        conditions.append("and yp.rklxdm =  %(人口类型代码)s")
        人口类型代码 = 字典_人口类型代码[人口类型]
        params["人口类型代码"] = f"{人口类型代码}"

    if 房屋编码 is not None:
        conditions.append("and yh.fwbm = %(房屋编码)s")
        params["房屋编码"] = f"{房屋编码}"

    # 拼接sql
    sql += " " + " ".join(conditions)
    sql += ' order by yh.dyh + "0" asc ,yh.mph + "0"'
    return sql, params

@pytest.mark.usefixtures("前置操作_获取房屋编码")
class TestQuery(BaseCase):

    @pytest.mark.usefixtures("后置操作_重置查询条件")
    @pytest.mark.parametrize(
        "姓名, 联系电话_明文, 联系电话_密文, 人口类型",
        [
            (None, None, None, None),
            ("石岱宗", None, None, None),
            (None, "15655426822", "3FC0AF9C731AB634D08E4AD7E0ED30B1", None),
            (None, None, None, "流动人口"),
            ("石岱宗", "15655426822", "3FC0AF9C731AB634D08E4AD7E0ED30B1", None),
            ("石岱宗", None, None, "常住人口"),
            ("石岱宗", "15655426822", "3FC0AF9C731AB634D08E4AD7E0ED30B1", "常住人口"),

        ]
    )
    def test_query(self, 一房一档页面, db_connection, 前置操作_获取房屋编码, 姓名, 联系电话_明文, 联系电话_密文,  人口类型):
        房屋编码 = 前置操作_获取房屋编码
        # 输入查询条件
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=姓名, 联系电话=联系电话_明文, 人口类型=人口类型)

        self.log_step("输入查询条件")

        # 获取查询接口响应的数据
        查询接口返回的数据 = 一房一档页面.获取查询接口响应的数据("搜索", r"/ybdsPerson/queryPersonList")
        self.log_step("获取查询接口响应的数据")

        # 构建 SQL 查询
        sql, params = build_query_sql(姓名=姓名, 联系电话=联系电话_密文, 人口类型=人口类型, 房屋编码=房屋编码)

        # 根据sql语句和参数，从数据库中提取数据
        db_data = 一房一档页面.get_db_data(db_connection, query=sql, params=params)
        self.log_step("从数据库中提取数据")

        # 对比数据
        assert 一房一档页面.对比查询接口数据和数据库数据(查询接口返回的数据, db_data,
                                                         ['xqmc', 'xm', 'zjhm', 'sjhm', 'yhzgxdm'])
        self.log_step("比较两个数据集")


class TestReset(BaseCase):
    def test_reset(self, 一房一档页面, db_connection, 前置操作_获取房屋编码):
        房屋编码 = 前置操作_获取房屋编码
        # 输入查询条件
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名="石岱宗", 联系电话="15655426822", 人口类型="常住人口")
        self.log_step("输入查询条件")

        # 点击重置按钮，获取查询接口响应的数据
        查询接口返回的数据 = 一房一档页面.获取查询接口响应的数据("重置", r"/ybdsPerson/queryPersonList")
        self.log_step("获取查询接口响应的数据")

        # 构建 SQL 查询
        sql, params = build_query_sql(姓名=None, 联系电话=None, 人口类型=None, 房屋编码=房屋编码)

        # 根据sql语句和参数，从数据库中提取数据
        db_data = 一房一档页面.get_db_data(db_connection, query=sql, params=params)
        self.log_step("从数据库中提取数据")

        # 对比数据
        assert 一房一档页面.对比查询接口数据和数据库数据(查询接口返回的数据, db_data,
                                                         ['xqmc', 'xm', 'zjhm', 'sjhm', 'yhzgxdm'])
        self.log_step("比较两个数据集")

        一房一档页面.校验表单中数据成功修改(姓名="", 联系电话="", 人口类型="")


@pytest.mark.usefixtures("后置操作_重置查询条件")
class TestDelete(BaseCase):
    @pytest.mark.parametrize(
        "待删除的姓名",
        [
            "修改-成功"
        ]
    )
    def test_delete_success(self, 一房一档页面, db_connection, 待删除的姓名):
        # 修改后的门牌号 = "103"
        # 从数据库中统计状态为删除的数据条数
        数据库中数据量_删除前 = 一房一档页面.统计数据库表中的记录数(db_connection)
        # 查找待删除的记录
        # 输入查询条件
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=待删除的姓名)
        self.log_step("输入查询条件")
        # 点击查询按钮，获取查询接口响应的数据
        查询接口返回的数据 = 一房一档页面.获取查询接口响应的数据("搜索", r"/ybdsPerson/queryPersonList")
        查询接口数据量_删除前 = 查询接口返回的数据["data"]["total"]
        self.log_step("获取查询接口响应的数据量")
        # 点击删除按钮
        一房一档页面.点击删除按钮(None)
        一房一档页面.click_button("确定")
        self.log_step("点击删除按钮,弹窗后点击确定按钮")
        expect(一房一档页面.page.get_by_text("删除成功")).to_be_visible(timeout=5000)
        self.log_step("验证页面出现删除成功字样")
        # 等待1秒
        一房一档页面.page.wait_for_timeout(1000)
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=待删除的姓名)
        self.log_step("输入查询条件")
        # 点击查询按钮，获取查询接口响应的数据
        查询接口返回的数据 = 一房一档页面.获取查询接口响应的数据("搜索", r"/ybdsPerson/queryPersonList")
        查询接口数据量_删除后 = 查询接口返回的数据["data"]["total"]
        self.log_step("获取查询接口响应的数据量")
        # 断言：表格中的行数减1
        assert 查询接口数据量_删除后 == 查询接口数据量_删除前 - 1, "表格中的行数未减少"
        # 验证数据库中的数据是否已删除（或标记为已删除）
        db_connection.ping(reconnect=True)  # 确保数据库连接有效
        db_connection.commit()
        数据库中数据量_删除后 = 一房一档页面.统计数据库表中的记录数(db_connection)
        # 断言：数据库中状态为已删除的数据多了1条
        assert 数据库中数据量_删除后 == 数据库中数据量_删除前 - 1, "数据库中的数据未删除"
        self.log_step("验证数据库中的数据是否已删除")

    @pytest.mark.parametrize("待删除的姓名", [
        "石岱宗"
    ])
    def test_delete_cancel(self, 一房一档页面, db_connection, 待删除的姓名):
        # 从数据库中统计状态为删除的数据条数
        数据库中数据量_删除前 = 一房一档页面.统计数据库表中的记录数(db_connection)
        # 查找待删除的记录
        # 输入查询条件
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=待删除的姓名)
        self.log_step("输入查询条件")
        # 点击查询按钮，获取查询接口响应的数据
        查询接口返回的数据 = 一房一档页面.获取查询接口响应的数据("搜索", r"/ybdsPerson/queryPersonList")
        查询接口数据量_删除前 = 查询接口返回的数据["data"]["total"]
        self.log_step("获取查询接口响应的数据量")
        # 点击删除按钮
        一房一档页面.点击删除按钮(None)
        一房一档页面.click_button("取消")
        self.log_step("点击删除按钮,弹窗后点击取消按钮")
        expect(一房一档页面.page.get_by_text("删除成功")).not_to_be_visible(timeout=5000)
        self.log_step("验证页面未出现删除成功字样")
        # 等待1秒
        一房一档页面.page.wait_for_timeout(1000)
        一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(姓名=待删除的姓名)
        self.log_step("输入查询条件")
        # 点击查询按钮，获取查询接口响应的数据
        查询接口返回的数据 = 一房一档页面.获取查询接口响应的数据("搜索", r"/ybdsPerson/queryPersonList")
        查询接口数据量_删除后 = 查询接口返回的数据["data"]["total"]
        self.log_step("获取查询接口响应的数据量")
        # 断言：表格中的行数减1
        assert 查询接口数据量_删除后 == 查询接口数据量_删除前, "表格中的行数减少了"
        # 验证数据库中的数据是否已删除（或标记为已删除）
        db_connection.ping(reconnect=True)  # 确保数据库连接有效
        db_connection.commit()
        数据库中数据量_删除后 = 一房一档页面.统计数据库表中的记录数(db_connection)
        # 断言：数据库中状态为已删除的数据不变
        assert 数据库中数据量_删除后 == 数据库中数据量_删除前, "数据库中的数据被删除了"
        self.log_step("验证数据库中的数据是否已删除")

# @pytest.mark.usefixtures("后置操作_重置查询条件")
# class TestDeleteBatch(BaseCase):
#     def test_delete_batch_success(self, 一房一档页面, db_connection, 待删除数据的门牌号, 删除数据数量):
#         # 待删除数据的门牌号 = "103"
#         # 从数据库中统计状态为删除的数据条数
#         数据库中数据量_删除前 = 一房一档页面.统计数据库表中的记录数(db_connection)
#         # 查找待删除的记录
#         一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(门牌号=待删除数据的门牌号)
#         查询接口返回的数据 = 一房一档页面.获取查询接口响应的数据("搜索")
#         查询接口数据量_删除前 = 查询接口返回的数据["data"]["total"]
#         self.log_step("获取查询接口响应的数据量")
#         # 勾选并点击批量删除按钮
#         一房一档页面.点击批量删除按钮(待删除数据的门牌号, 删除数据数量)
#         一房一档页面.click_button("确定")
#         self.log_step("点击批量删除按钮,弹窗后点击确定按钮")
#         expect(一房一档页面.page.get_by_text("删除成功")).to_be_visible(timeout=5000)
#         self.log_step("验证页面出现删除成功字样")
#         # 等待1秒
#         # 查找待删除的记录
#         一房一档页面.快捷操作_填写表单_增加根据数据类确定唯一表单版(门牌号=待删除数据的门牌号)
#         查询接口返回的数据 = 一房一档页面.获取查询接口响应的数据("搜索")
#         查询接口数据量_删除后 = 查询接口返回的数据["data"]["total"]
#         self.log_step("获取查询接口响应的数据量")
#         # 断言：查询接口的数据量减少了
#         assert 查询接口数据量_删除后 == 查询接口数据量_删除前 - 删除数据数量, "查询接口数据量未减少"
#         # 验证数据库中的数据是否已删除（或标记为已删除）
#         db_connection.ping(reconnect=True)  # 确保数据库连接有效
#         db_connection.commit()
#         数据库中数据量_删除后 = 一房一档页面.统计数据库表中的记录数(db_connection)
#         # 断言：数据库中状态为已删除的数据多了1条
#         assert 数据库中数据量_删除后 == 数据库中数据量_删除前 - 删除数据数量, "数据库中的数据未删除"
#         self.log_step("验证数据库中的数据是否已删除")
